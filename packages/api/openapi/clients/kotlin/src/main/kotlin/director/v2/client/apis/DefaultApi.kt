/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package director.v2.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl
import okhttp3.HttpUrl.Companion.toHttpUrlOrNull

import director.v2.client.models.EventsListEvents200Response
import director.v2.client.models.EventsListEventsLive200Response
import director.v2.client.models.HealthLiveOk200Response
import director.v2.client.models.OdienceProvisionUser200Response
import director.v2.client.models.OdienceProvisionUserRequest
import director.v2.client.models.OdienceValidatePhoneNumber200Response
import director.v2.client.models.OdienceValidatePhoneNumberRequest
import director.v2.client.models.StreamGetStreamUrls200Response
import director.v2.client.models.StreamGetStreamUrlsRequest
import director.v2.client.models.UserGetUserInfo200Response
import director.v2.client.models.UserGetUserInfoByMsisdnRequest

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import director.v2.client.infrastructure.ApiClient
import director.v2.client.infrastructure.ApiResponse
import director.v2.client.infrastructure.ClientException
import director.v2.client.infrastructure.ClientError
import director.v2.client.infrastructure.ServerException
import director.v2.client.infrastructure.ServerError
import director.v2.client.infrastructure.MultiValueMap
import director.v2.client.infrastructure.PartConfig
import director.v2.client.infrastructure.RequestConfig
import director.v2.client.infrastructure.RequestMethod
import director.v2.client.infrastructure.ResponseType
import director.v2.client.infrastructure.Success
import director.v2.client.infrastructure.toMultiValue
import okhttp3.Request
import okhttp3.sse.EventSource
import okhttp3.sse.EventSources
import okhttp3.sse.EventSourceListener

/**
 * Callback interface for Server-Sent Events (SSE)
 */
interface SseCallback {
    /**
     * Called when a new SSE event is received
     * @param event The event type (e.g., "message", "done", "error")
     * @param data The event data
     * @param id The event ID (optional)
     */
    fun onEvent(event: String, data: String, id: String?)
    
    /**
     * Called when the SSE connection is opened
     */
    fun onOpen()
    
    /**
     * Called when the SSE connection is closed
     */
    fun onClosed()
    
    /**
     * Called when an error occurs
     * @param error The error that occurred
     */
    fun onFailure(error: Throwable)
}

/**
 * OkHttp EventSourceListener adapter that delegates to SseCallback
 */
class SseEventSourceListener(
    private val callback: SseCallback
) : EventSourceListener() {
    
    override fun onOpen(eventSource: EventSource, response: okhttp3.Response) {
        callback.onOpen()
    }
    
    override fun onEvent(
        eventSource: EventSource, 
        id: String?, 
        type: String?, 
        data: String
    ) {
        callback.onEvent(type ?: "message", data, id)
    }
    
    override fun onClosed(eventSource: EventSource) {
        callback.onClosed()
    }
    
    override fun onFailure(eventSource: EventSource, t: Throwable?, response: okhttp3.Response?) {
        val errorMessage = buildString {
            append("SSE connection failed")
            if (response != null) {
                append(" - Status: ${response.code}")
                append(", Message: ${response.message}")
                response.body?.let { body ->
                    try {
                        append(", Body: ${body.string()}")
                    } catch (e: Exception) {
                        append(", Body: <error reading body>")
                    }
                }
            }
            if (t != null) {
                append(", Error: ${t.message}")
            }
        }
        callback.onFailure(t ?: Exception(errorMessage))
    }
}

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /events/listEvents
     * 
     * 
     * @param body  (optional)
     * @return EventsListEvents200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun eventsListEvents(body: kotlin.Any? = null) : EventsListEvents200Response = withContext(Dispatchers.IO) {
        val localVarResponse = eventsListEventsWithHttpInfo(body = body)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventsListEvents200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /events/listEvents
     * 
     * 
     * @param body  (optional)
     * @return ApiResponse<EventsListEvents200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun eventsListEventsWithHttpInfo(body: kotlin.Any?) : ApiResponse<EventsListEvents200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = eventsListEventsRequestConfig(body = body)

        return@withContext request<kotlin.Any, EventsListEvents200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsListEvents
     *
     * @param body  (optional)
     * @return RequestConfig
     */
    fun eventsListEventsRequestConfig(body: kotlin.Any?) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/events/listEvents",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /events/listEventsLive
     * 
     * 
     * @param body  (optional)
     * @return EventsListEventsLive200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun eventsListEventsLive(body: kotlin.Any? = null) : EventsListEventsLive200Response = withContext(Dispatchers.IO) {
        val localVarResponse = eventsListEventsLiveWithHttpInfo(body = body)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventsListEventsLive200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /events/listEventsLive (SSE)
     * 
     * 
     *
     * This endpoint returns Server-Sent Events. Use the callback to handle streaming events.
     * @param body  (optional)
     * @param callback Callback to handle SSE events
     * @return EventSource that can be used to close the connection
     * @throws IllegalStateException If the request is not correctly configured
     */
    @Throws(IllegalStateException::class)
    fun eventsListEventsLiveSse(body: kotlin.Any? = null, callback: SseCallback) : EventSource {
        val localVariableConfig = eventsListEventsLiveRequestConfig(body = body)
        
        val baseHttpUrl = baseUrl.toHttpUrlOrNull() ?: throw IllegalStateException("Invalid base URL: $baseUrl")
        val pathSegments = baseHttpUrl.encodedPathSegments.toMutableList()
        // Add the operation path segments
        localVariableConfig.path.trimStart('/').split('/').filter { it.isNotEmpty() }.forEach {
            pathSegments.add(it)
        }
        
        val url = HttpUrl.Builder()
            .scheme(baseHttpUrl.scheme)
            .host(baseHttpUrl.host)
            .port(baseHttpUrl.port)
            .apply {
                pathSegments.forEach { segment ->
                    addPathSegment(segment)
                }
            }
        
        localVariableConfig.query.forEach { (key, values) ->
            values.forEach { value ->
                url.addQueryParameter(key, value)
            }
        }
        
        val requestBuilder = Request.Builder()
            .url(url.build())
            .get()
        
        localVariableConfig.headers.forEach { (key, value) ->
            requestBuilder.addHeader(key, value)
        }
        
        requestBuilder.addHeader("Accept", "text/event-stream")
        
        val request = requestBuilder.build()
        val listener = SseEventSourceListener(callback)
        
        return EventSources.createFactory(client as okhttp3.OkHttpClient)
            .newEventSource(request, listener)
    }

    /**
     * POST /events/listEventsLive
     * 
     * 
     * @param body  (optional)
     * @return ApiResponse<EventsListEventsLive200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun eventsListEventsLiveWithHttpInfo(body: kotlin.Any?) : ApiResponse<EventsListEventsLive200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = eventsListEventsLiveRequestConfig(body = body)

        return@withContext request<kotlin.Any, EventsListEventsLive200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsListEventsLive
     *
     * @param body  (optional)
     * @return RequestConfig
     */
    fun eventsListEventsLiveRequestConfig(body: kotlin.Any?) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/events/listEventsLive",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /events/listPartialEvents
     * 
     * 
     * @param body  (optional)
     * @return EventsListEvents200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun eventsListPartialEvents(body: kotlin.Any? = null) : EventsListEvents200Response = withContext(Dispatchers.IO) {
        val localVarResponse = eventsListPartialEventsWithHttpInfo(body = body)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventsListEvents200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /events/listPartialEvents
     * 
     * 
     * @param body  (optional)
     * @return ApiResponse<EventsListEvents200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun eventsListPartialEventsWithHttpInfo(body: kotlin.Any?) : ApiResponse<EventsListEvents200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = eventsListPartialEventsRequestConfig(body = body)

        return@withContext request<kotlin.Any, EventsListEvents200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsListPartialEvents
     *
     * @param body  (optional)
     * @return RequestConfig
     */
    fun eventsListPartialEventsRequestConfig(body: kotlin.Any?) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/events/listPartialEvents",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /health/liveOk
     * 
     * 
     * @param maxOutputs  (optional)
     * @return HealthLiveOk200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun healthLiveOk(maxOutputs: java.math.BigDecimal? = null) : HealthLiveOk200Response = withContext(Dispatchers.IO) {
        val localVarResponse = healthLiveOkWithHttpInfo(maxOutputs = maxOutputs)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as HealthLiveOk200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /health/liveOk (SSE)
     * 
     * 
     *
     * This endpoint returns Server-Sent Events. Use the callback to handle streaming events.
     * @param maxOutputs  (optional)
     * @param callback Callback to handle SSE events
     * @return EventSource that can be used to close the connection
     * @throws IllegalStateException If the request is not correctly configured
     */
    @Throws(IllegalStateException::class)
    fun healthLiveOkSse(maxOutputs: java.math.BigDecimal? = null, callback: SseCallback) : EventSource {
        val localVariableConfig = healthLiveOkRequestConfig(maxOutputs = maxOutputs)
        
        val baseHttpUrl = baseUrl.toHttpUrlOrNull() ?: throw IllegalStateException("Invalid base URL: $baseUrl")
        val pathSegments = baseHttpUrl.encodedPathSegments.toMutableList()
        // Add the operation path segments
        localVariableConfig.path.trimStart('/').split('/').filter { it.isNotEmpty() }.forEach {
            pathSegments.add(it)
        }
        
        val url = HttpUrl.Builder()
            .scheme(baseHttpUrl.scheme)
            .host(baseHttpUrl.host)
            .port(baseHttpUrl.port)
            .apply {
                pathSegments.forEach { segment ->
                    addPathSegment(segment)
                }
            }
        
        localVariableConfig.query.forEach { (key, values) ->
            values.forEach { value ->
                url.addQueryParameter(key, value)
            }
        }
        
        val requestBuilder = Request.Builder()
            .url(url.build())
            .get()
        
        localVariableConfig.headers.forEach { (key, value) ->
            requestBuilder.addHeader(key, value)
        }
        
        requestBuilder.addHeader("Accept", "text/event-stream")
        
        val request = requestBuilder.build()
        val listener = SseEventSourceListener(callback)
        
        return EventSources.createFactory(client as okhttp3.OkHttpClient)
            .newEventSource(request, listener)
    }

    /**
     * GET /health/liveOk
     * 
     * 
     * @param maxOutputs  (optional)
     * @return ApiResponse<HealthLiveOk200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun healthLiveOkWithHttpInfo(maxOutputs: java.math.BigDecimal?) : ApiResponse<HealthLiveOk200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = healthLiveOkRequestConfig(maxOutputs = maxOutputs)

        return@withContext request<Unit, HealthLiveOk200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation healthLiveOk
     *
     * @param maxOutputs  (optional)
     * @return RequestConfig
     */
    fun healthLiveOkRequestConfig(maxOutputs: java.math.BigDecimal?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxOutputs != null) {
                    put("max_outputs", listOf(maxOutputs.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/health/liveOk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /health/ok
     * 
     * 
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun healthOk() : kotlin.String = withContext(Dispatchers.IO) {
        val localVarResponse = healthOkWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /health/ok
     * 
     * 
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun healthOkWithHttpInfo() : ApiResponse<kotlin.String?> = withContext(Dispatchers.IO) {
        val localVariableConfig = healthOkRequestConfig()

        return@withContext request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation healthOk
     *
     * @return RequestConfig
     */
    fun healthOkRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/health/ok",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /odience/getCategoryList
     * 
     * 
     * @return kotlin.collections.Map<kotlin.String, kotlin.String>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun odienceGetCategoryList() : kotlin.collections.Map<kotlin.String, kotlin.String> = withContext(Dispatchers.IO) {
        val localVarResponse = odienceGetCategoryListWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, kotlin.String>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /odience/getCategoryList
     * 
     * 
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.String>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun odienceGetCategoryListWithHttpInfo() : ApiResponse<kotlin.collections.Map<kotlin.String, kotlin.String>?> = withContext(Dispatchers.IO) {
        val localVariableConfig = odienceGetCategoryListRequestConfig()

        return@withContext request<Unit, kotlin.collections.Map<kotlin.String, kotlin.String>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation odienceGetCategoryList
     *
     * @return RequestConfig
     */
    fun odienceGetCategoryListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/odience/getCategoryList",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /odience/provisionUser
     * 
     * 
     * @param odienceProvisionUserRequest 
     * @return OdienceProvisionUser200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun odienceProvisionUser(odienceProvisionUserRequest: OdienceProvisionUserRequest) : OdienceProvisionUser200Response = withContext(Dispatchers.IO) {
        val localVarResponse = odienceProvisionUserWithHttpInfo(odienceProvisionUserRequest = odienceProvisionUserRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OdienceProvisionUser200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /odience/provisionUser
     * 
     * 
     * @param odienceProvisionUserRequest 
     * @return ApiResponse<OdienceProvisionUser200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun odienceProvisionUserWithHttpInfo(odienceProvisionUserRequest: OdienceProvisionUserRequest) : ApiResponse<OdienceProvisionUser200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = odienceProvisionUserRequestConfig(odienceProvisionUserRequest = odienceProvisionUserRequest)

        return@withContext request<OdienceProvisionUserRequest, OdienceProvisionUser200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation odienceProvisionUser
     *
     * @param odienceProvisionUserRequest 
     * @return RequestConfig
     */
    fun odienceProvisionUserRequestConfig(odienceProvisionUserRequest: OdienceProvisionUserRequest) : RequestConfig<OdienceProvisionUserRequest> {
        val localVariableBody = odienceProvisionUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/odience/provisionUser",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /odience/validatePhoneNumber
     * 
     * 
     * @param odienceValidatePhoneNumberRequest 
     * @return OdienceValidatePhoneNumber200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun odienceValidatePhoneNumber(odienceValidatePhoneNumberRequest: OdienceValidatePhoneNumberRequest) : OdienceValidatePhoneNumber200Response = withContext(Dispatchers.IO) {
        val localVarResponse = odienceValidatePhoneNumberWithHttpInfo(odienceValidatePhoneNumberRequest = odienceValidatePhoneNumberRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OdienceValidatePhoneNumber200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /odience/validatePhoneNumber
     * 
     * 
     * @param odienceValidatePhoneNumberRequest 
     * @return ApiResponse<OdienceValidatePhoneNumber200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun odienceValidatePhoneNumberWithHttpInfo(odienceValidatePhoneNumberRequest: OdienceValidatePhoneNumberRequest) : ApiResponse<OdienceValidatePhoneNumber200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = odienceValidatePhoneNumberRequestConfig(odienceValidatePhoneNumberRequest = odienceValidatePhoneNumberRequest)

        return@withContext request<OdienceValidatePhoneNumberRequest, OdienceValidatePhoneNumber200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation odienceValidatePhoneNumber
     *
     * @param odienceValidatePhoneNumberRequest 
     * @return RequestConfig
     */
    fun odienceValidatePhoneNumberRequestConfig(odienceValidatePhoneNumberRequest: OdienceValidatePhoneNumberRequest) : RequestConfig<OdienceValidatePhoneNumberRequest> {
        val localVariableBody = odienceValidatePhoneNumberRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/odience/validatePhoneNumber",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /stream/getStreamUrls
     * 
     * 
     * @param streamGetStreamUrlsRequest 
     * @return StreamGetStreamUrls200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun streamGetStreamUrls(streamGetStreamUrlsRequest: StreamGetStreamUrlsRequest) : StreamGetStreamUrls200Response = withContext(Dispatchers.IO) {
        val localVarResponse = streamGetStreamUrlsWithHttpInfo(streamGetStreamUrlsRequest = streamGetStreamUrlsRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StreamGetStreamUrls200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /stream/getStreamUrls
     * 
     * 
     * @param streamGetStreamUrlsRequest 
     * @return ApiResponse<StreamGetStreamUrls200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun streamGetStreamUrlsWithHttpInfo(streamGetStreamUrlsRequest: StreamGetStreamUrlsRequest) : ApiResponse<StreamGetStreamUrls200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = streamGetStreamUrlsRequestConfig(streamGetStreamUrlsRequest = streamGetStreamUrlsRequest)

        return@withContext request<StreamGetStreamUrlsRequest, StreamGetStreamUrls200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation streamGetStreamUrls
     *
     * @param streamGetStreamUrlsRequest 
     * @return RequestConfig
     */
    fun streamGetStreamUrlsRequestConfig(streamGetStreamUrlsRequest: StreamGetStreamUrlsRequest) : RequestConfig<StreamGetStreamUrlsRequest> {
        val localVariableBody = streamGetStreamUrlsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stream/getStreamUrls",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /user/getUserInfo
     * 
     * 
     * @param body 
     * @return UserGetUserInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun userGetUserInfo(body: kotlin.Any) : UserGetUserInfo200Response = withContext(Dispatchers.IO) {
        val localVarResponse = userGetUserInfoWithHttpInfo(body = body)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetUserInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /user/getUserInfo
     * 
     * 
     * @param body 
     * @return ApiResponse<UserGetUserInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun userGetUserInfoWithHttpInfo(body: kotlin.Any) : ApiResponse<UserGetUserInfo200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = userGetUserInfoRequestConfig(body = body)

        return@withContext request<kotlin.Any, UserGetUserInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetUserInfo
     *
     * @param body 
     * @return RequestConfig
     */
    fun userGetUserInfoRequestConfig(body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/user/getUserInfo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /user/getUserInfoByMsisdn
     * 
     * 
     * @param userGetUserInfoByMsisdnRequest 
     * @return UserGetUserInfo200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun userGetUserInfoByMsisdn(userGetUserInfoByMsisdnRequest: UserGetUserInfoByMsisdnRequest) : UserGetUserInfo200Response = withContext(Dispatchers.IO) {
        val localVarResponse = userGetUserInfoByMsisdnWithHttpInfo(userGetUserInfoByMsisdnRequest = userGetUserInfoByMsisdnRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGetUserInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /user/getUserInfoByMsisdn
     * 
     * 
     * @param userGetUserInfoByMsisdnRequest 
     * @return ApiResponse<UserGetUserInfo200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun userGetUserInfoByMsisdnWithHttpInfo(userGetUserInfoByMsisdnRequest: UserGetUserInfoByMsisdnRequest) : ApiResponse<UserGetUserInfo200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = userGetUserInfoByMsisdnRequestConfig(userGetUserInfoByMsisdnRequest = userGetUserInfoByMsisdnRequest)

        return@withContext request<UserGetUserInfoByMsisdnRequest, UserGetUserInfo200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userGetUserInfoByMsisdn
     *
     * @param userGetUserInfoByMsisdnRequest 
     * @return RequestConfig
     */
    fun userGetUserInfoByMsisdnRequestConfig(userGetUserInfoByMsisdnRequest: UserGetUserInfoByMsisdnRequest) : RequestConfig<UserGetUserInfoByMsisdnRequest> {
        val localVariableBody = userGetUserInfoByMsisdnRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/user/getUserInfoByMsisdn",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
